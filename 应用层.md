[TOC]

# 应用层

## 概述：

### 目的

- 网络应用以及应用层协议的概念、实现

  传输服务模型

  客户服务器模式

  对等模式peer-to-peer

- 通过对主流应用层协议分析来掌握应用层协议

  HTTP

  FTP

  SMTP、POP3、IMAP

  DNS

- 网络编程应用

  socket API

### 主要内容

2.1应用层协议原理

2.2Web英语和HTTP协议

2.3文件传输协议：FTP

2.4因特网中的电子邮件

- SMTP，POP3，IMAP

2.5DNS：互联网目录服务

2.6P2P

2.7TCP套接字编程

### 一些网络应用的例子

电子邮件、Web、即时讯息、远程登录、P2P、计算机文件共享、game、流式存储视频片段、网络电话、视频会议

## 应用层协议原理

### 研发网络应用程序

#### 研发网络应用程序的核心

- 写出能够在不同终端系统运行的并通过网络彼此通信的程序
- 例如WEB、WEB服务器软件和软件浏览器通信

#### 没有应用程序软件运行在网络核心设备上

- 网络核心设备不在应用层起作用（其负责更为底层的作用）
- 这种设计方法促进了应用程序研发

### 网络应用程序体系结构

#### 客户机、服务器体系结构

- 服务器

  > 总是打开主机
  >
  > 有固定、众所周知的IP
  >
  > 主机集群常用于创建强大的虚拟服务器（巨型数据中心）

- 客户机

  > 同服务器端桐乡新
  >
  > 动态ip
  >
  > 不直接通信（同客户机）
  >
  > 可以同间断的服务器间连接；

==比如==：

浏览百度的bai网页，你的电脑就是客户端，而百度网页所存放的机器就是服务器。你通过internet互联网连到百度网页服务器，才能浏览网页。

#### P2P体系结构

- 没有总是打开的服务器（不依赖位于数据中心的专用服务器，如果有的话，主要被用于追踪用户的ip）
- 任意一对主机直接通信
- 对等方向其他方提供接受服务
- 缺点：难以管理
- 优点：高拓展

==比如==：

文件共享BitTorrent，迅雷的下载加速服务，网络电话和视频会议（Skype）

#### 客户机、服务器和P2P混合的体系结构

Napster

- 文件直接在对等方传输

- 文件搜素通过服务器

  中心服务器记录对等方内容

  对等方查询中心服务器决定要求的文件位置

即时通讯

- 两个终端中间是用P2P通讯

- 注册查询通过服务器

  用户上限要通过服务器进行通信

  用户与中心服务器联系

### 进程通信

**进程**：一个在端系统中运行的程序（比如电脑上打开的QQ，浏览器）

- 同一主机上的两个进程通过内部进程进行联系（在此不做关注）
- 不同主机上通过*报文*（网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。）联系

**客户机进程：**发起通信的进程

**服务器进程：**等待联系的进程

很多场景都可以定义客户和服务器（B请求A向B传文件，A可认为是服务器，B可认为是客户端）

### 套接字

- 进程通过它的套接字在网络上发送接收报文

- 套接字类比于门户

  发送进程把报文推出程序

  发送进程假定门户到另外一侧之间有传输设施，该设施可以传送报文到接收进程

即：可以理解为进程同传输路径交互的一种接口（通过套接字实际上可以选择运输层协议、设置参数等）套接字还有另一个名字：API（Application Programming Interface），通常是由开发者手动实现的。

### 进程寻址

- 为了一个进程能够接受报文，它需要一个标识，进程标识包含IP地址和端口号
- 主机有一个唯一的32位IP地址；常用应用程序的端口号W\===web服务：80；邮件服务：25==
- 主机的IP地址能够表示进程吗？不可以因为主机上有很多进程
- 发送HTTP分组到==web服务器==，通过==端口号80==得知是相应的HTTP协议

也就是说，IP地址不能作为标识，反之，端口号可以

### 应用层协议

- 交换的报文类型：如请求报文和应答报文
- 报文类型的语法：报文中的各个字段及其详细描述
- 字段的语义：包含在字段中的信息的含义
- 进程何时、如何发送报文及对报文如何响应

<font color='red'>公共领域协议：</font>

- 由RFC文档定义（Web的应用层协议HTTP）
- 可供大家使用
- 例如：HTTP，SMTP（简单邮件传输协议）

<font color='red'>专用协议：</font>

例如：Skype

### 应用需要什么服务：

- 数据丢失率

  一些应用，能容忍一定程度的数据丢失（试试音频、视频）——分组在传输过程中可能会丢失（路由器缓存溢出，比特损坏被丢弃）

  另一些应用需要100%可靠的数据传输（文件传输、银行、邮件传输、远程主机访问）

- 带宽（吞吐量：发送进程能够向接收进程交付比特的速率），==单位：比特每秒==

  吞吐量会随时间波动，因为其它会话会沿着该网络路径的带宽（且会话会离开），可用吞吐量将随时间波动

  一些应用必须达到所需带宽（多媒体）→==带宽敏感的应用==（在吞吐量不达标准时会以低效率进行编码运行或者停止运行）

  另一些应用根据需要充分利用可供使用的带宽（电子邮件，文件传输和web传输）→==弹性应用==（根据可用带宽尽可能利用吞吐量） 

- 定时

  除了对吞吐量要求保证，还有一些程序要求定时保证（发射方的比特到达接收方的套接字不超过xxms）

  一些应用要求低延时（游戏、网络电话）

- 安全

  加密、数据完整

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201102230231009.png" alt="image-20201102230231009" style="zoom:50%;" />

### 计算机网络提供的应用的服务

TCP协议

- 面向连接的服务：在客户机程序和服务器程序之间必须建立联系（在数据流动前）→==握手阶段==（之后便形成可靠的TCP连接，且双方都可以互相接收发送报文）

- 可靠的传输服务：接受和发送进程间不会出现数据丢失冗余
- 流量控制：发送方不会淹没接收方
- 拥塞控制：网络出行拥塞时抑制发送进程（不一定对通信进程有好处，但是对网络整体有好处）
- 没有保证：时延保证，最小带宽保证
- 安全性：TCP本身无加密机制，但是目前已使用SSL（安全套接字层）来加强安全性

UDP协议

- 不可靠数据传输（不提供不必要服务的轻量运输协议，仅提供最小服务）
- 没有提供：建立连接（无握手）、可靠性（不保证数据能否到达，且可能是乱序的）、流量控制，拥塞控制、时延和带宽保证

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201102231247773.png" alt="image-20201102231247773" style="zoom:50%;" />

流媒体和网络电话通常使用UDP是因为其想要避开TCP的拥塞控制（但是这种经常被防火墙拦截，此时它会转向TCP）

在现有协议中，时间保证并没有被提供（大多数应用都有办法去应对这种问题）

## Web应用和HTTP协议

### 常用术语：

- 网页（Web页，或称文档），由很多对象组成

- 对象就是文件，可以是HTML文件，JPEG图像和Java Applet，音频文件

- 多数网页由单个基本HTMl文件和若干个所引用的对象组成（一个网站上包含文本文件、图片、程序和视频等内容）

  > 如果一个Web文件中有5个图片，那么最终它有6个对象——自身的HTML文档和5个图形文件

- 每个网站被一个URL（统一资源定位符）寻址

- 浏览器实现了HTTP的客户端，而Web服务器（Apache和Microsoft Internet Information Server）是HTTP的服务器端，用于存储Web对象）

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201102232148092.png" alt="image-20201102232148092" style="zoom:50%;" />

### HTTP概述

==HTTP：==超文本传输协议（Hypertext Transfer Protocol）

- Web的应用层协议
- Client/Server模式
  - Client：浏览器browser请求，接收，“解释显示”Web对象
  - Server：Web服务器响应请求，发送Web对象
- HTTP 1.0：在RFC 1945中定义
- HTTP 1.1：在RFC 2616定义

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103170329967.png" alt="image-20201103170329967" style="zoom:50%;" />

**使用TCP：**

- 客户初始化一个HTTP服务器80端口的TCP连接（创建套接字，发送请求报文）
- HTTP服务器接受来自客户的TCP连接请求并建立连接（报文不收控制而是TCP控制）
- Browser（HTTP Client）和Web服务器（HTTP Server）交换HTTP消息（应用层协议消息）包括HTTP请求和响应消息
- 最后结束（或叫关闭）TCP连接

**HTTP是无状态协议**

- HTTP不维护客户先前的状态信息（维护状态的协议非常复杂，它必须维护过去历史——状态信息；如果Server/Client崩溃，它们各自的状态视图可能不一致，因而必须保持协调一致）

↓

服务器仅仅负责向客户机发送被请求的文件而不负责存储（这也就是为什么客户在短时间内请求同一对象时，服务器不会因为刚刚向该客户提供了该对象就不再作出反应） 

### HTTP连接

**非持久HTTP连接（每个请求/响应是经由一个单独TCP连接发送的）**

- 每个TCP对象上只能传送一个对象
- HTTP/1.0使用非持久HTTP连接

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103180053684.png" alt="image-20201103180053684" style="zoom:50%;" />

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103180122749.png" alt="image-20201103180122749" style="zoom:50%;" />

现代浏览器可以选择使用串行建立连接或是并行建立连接（前者是每次处理一个TCP，后者是每次处理多个TCP）

*非持久HTTP连接的问题：*

- 每个对象需要两个RTT
- OS必须为每个TCP连接分配主机资源
- 大量客户的并发TCP连接给服务器带来严重负担

**持久HTTP连接（每个请求/响应是经由相同的TCP连接发送的）**

- 一个TCP连接上可以传送多个对象
- HTTP/1.1默认使用持久HTTP连接

---

- 服务器发送响应消息后保持连接
- 同1客户/服务器的后续HTTP消息继续在该连接上传送

*不带流水线的持久HTTP连接*

- 客户先前相应消息收到，才发出新的请求消息
- 每个引用对象经历一个RTT

*带流水线的持久HTTP连接*

- HTTP/1.1默认使用
- 客户遇到一个引用对象就发送请求消息（多个请求和回答交错）
- 所有引用对象只经历一个RTT

即：客户发送完请求报文后，服务器便打开TCP，用户便可以自由收发报文；如果用户端长时间未响应，服务器便关闭连接

### 响应时间模型（RTT）

往返时间RTT（Round-Trip Time）：一个小分组从客户机到服务器再到客户机所花费的时间

响应时间：

- 一个RTT用于建立TCP连接
- 一个RTT用于HTTP请求/响应
- HTML文件传输时间

total = 2RTT+transmit time

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103182939457.png" alt="image-20201103182939457" style="zoom:50%;" />

### HTTP报文格式

一共有两种HTTP报文，分别是请求报文request，响应报文response

#### HTTP请求报文：

- ASCII文本（易于人读格式）

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103184809889.png" alt="image-20201103184809889" style="zoom:50%;" />

##### 通用格式

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103184853430.png" alt="image-20201103184853430" style="zoom:50%;" />

在使用GET方法时实体主体为空，POST方法反之，之后会介绍；

##### 方法类型

**HTTP/1.0**

- GET

- POST

- HEAD

  服务器接收到请求时，用HTTP报文进行响应，但不返回请求对象

**HTTP/1.1**

- GET、POST、HEAD

- PUT

  文件在实体主体中被上载到URL字段指定的路径（人话：允许用户上传对象~（文件）~到指定的Web服务

- DELETE

  删除URL字段指定的路径

*POST方法：*

- 网页时常包含表单输入（用户在搜索引擎中输入关键字时）
- 输入值在请求报文的实体主体中被上载到服务器（Web页面的特定内容取决于用户在表单中输入的内容，实体主体中的内容就是用户在表单中的输入值）

*URL方法*

- 使用GET方法（对HTTP报文进行响应同时返回请求对象）

- 表单（各字段）输入值被上载，以URL请求行的字段：

  www.somesite.com/animalsearch?monkeys&banana

#### HTTP响应报文

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103220612168.png" alt="image-20201103220612168" style="zoom:50%;" />

Connection：close→发送完报文后会关闭TCP

Date：发送表文的时间

Server：表示报文是有一台Apache Web服务器产生的

Last-Modified：对象创建或最后修改的时间

Content-Length：被发送对象的字节数

Content-Type：实验体的对象是HTML文本

##### HTTP响应的状态码

==200==：OK

> 请求成功，所请求信息在响应消息中返回

==301==：Moved Permanently

> 所请求对象已永久迁移，新的URL在本响应消息的（location：）头部指出

==400==：Bad Request

> 该请求不能被服务器解读

==404==：Not Found

> 服务器上不存在所请求文档

==505==：HTTP Version Not Supported

> 该服务器类型不支持报文所使用的HTTP协议版本

### HTTP用户与服务器交互

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103222017750.png" alt="image-20201103222017750" style="zoom:50%;" />

#### 用户与服务器交互：Cookies

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103222832899.png" alt="image-20201103222832899" style="zoom:50%;" />

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103222846062.png" alt="image-20201103222846062" style="zoom:50%;" />

**Cookies的4个方面：**

- cookie的头部行在HTTP响应消息中
- cookie的头部行在HTTP请求消息中
- cookie文件保存在用户主机中并被用户浏览器管理
- cookie也被保存在Web站点的后端数据库

当用户接受了网站的cookie请求后（并生成cookie），其在访问时，HTTP响应报文将生成一个首部：

*Set-cookie:*

cookie主要是作为一个用户标识（在互联网上留下自己存在过的痕迹，即使只是一个ID识别码）

### Web缓存（代理服务器）

目标：代表起始服务器满足HTTP请求

用户配置浏览器：Web访问经由缓存

所有HTTP请求指向缓存：

- 用户通常会优先访问代理服务器（发送报文），如果对象副本在代理服务器缓存中：缓存区返回对象
- 否则缓存器向起始服务器发出请求，接收对象后转发给客户机（同时在本地保存一个副本）

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103223955448.png" alt="image-20201103223955448" style="zoom:50%;" />

为什么需要Web缓存器？

- 减少对客户机请求的响应时间
- 减少内部网络与接入链路上的通信量
- 能从整体上大大降低因特网的Web流量

代理服务器比较特殊，在它向用户发送表单时，它是一个服务器，而在它向初始服务器发送请求时，它是一个用户；其通常由ISP购买配置 

#### 缓存器举例

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103225230242.png" alt="image-20201103225230242" style="zoom:50%;" />

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103225346620.png" alt="image-20201103225346620" style="zoom:50%;" />

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103225525368.png" alt="image-20201103225525368" style="zoom:50%;" />

#### 条件GET方法

- 目的：证实缓存器中对象是否为最新

- 缓存器：在请求报文中包含对象最后修改时间

  If-modified-since: <date>

- 服务器：如果对象是最新的则响应报文中不包含对象：HTTP/1.0 304 Not Modified

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201103230954979.png" alt="image-20201103230954979" style="zoom:50%;" />

## 文件传输协议：FTP

FTP：文件传输协议

- 传输文件到远程主机/从远程主机上下载文件

- Client/Server模式

  Client：发起传输的一方

  Server：远程主机

- FTP：RFC 959

- FTP服务器：端口号 21

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201104085833226.png" alt="image-20201104085833226" style="zoom:50%;" />

### FTP：独立的连接控制，数据连接

- FTP客户首先发起建立1个与FTP服务器端口号21之间的TCP控制连接，指定TCP作为传输层协议
- 客户在建立的控制连接上获得身份认证
- 客户在建立的控制连接上发送命令来浏览远程主机的目录
- 当浏览器接收到一个文件传输命令时，在服务器端口号20创建一个与客户的TCP数据连接
- 一个文件传输后，服务器结束这个TCP数据连接

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201104090532343.png" alt="image-20201104090532343" style="zoom:50%;" />

- 服务器创建第二个TCP与客户的数据连接来传输下一个文件

- 控制连接：带外发送控制信息

- FTP服务器要维护用户状态信息：当前目录，先前的身份认证

  ### FTP命令和应答 

**常见命令：**

- 在控制连接上发送ASCII文本
- USER username
- PASS password
- LIST：返回挡圈远程目录的文件列表
- RETR filename：获取远程主机当前目录下的1个文件（get）
- STOR filename：存放1个文件到远程主机当前目录下（put）

**常见应答：**

- 状态码及其相应短语（同HTTP）
- 331 Username OK, password required
- 125 data connection already open; transfer starting
- 425 Can't open data connection
- 452 Error writing file

## 电子邮件（SMTP，POP3，IMAP）

**3个主要组成部分：**

- 用户代理user agent
- 邮件服务器mail servers
- 简单邮件传送协议simple mail transfer protocol：SMTP

**用户代理：**

- 允许用户阅读、回复、转发、保存、编辑邮件消息
- 例如：Outlook，Foxmail等
- 发送，接收邮件消息到/从服务器

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201104092726441.png" alt="image-20201104092726441" style="zoom:50%;" />

### 电子邮件：邮件服务器

**邮件服务器：**

- 邮箱mailbox存放用户接收的邮件消息

- 外出报文队列outgoing message queue

- SMTP协议在邮件服务器间发送邮件消息

  Client：运行在发送邮件消息

  Server：运行在接收邮件消息的服务器上

### SMTP[RFC 2821]

- 客户使用TCP来可靠传输邮件消息到服务器端口号25

- 直接传送：发送服务器到接收服务器

- 传输的三个阶段

  > 握手
  >
  > 邮件消息的传输
  >
  > 结束

- 命令/应答的交互

  > 命令：ASCII文本格式
  >
  > 应答：状态码及其短语

- 邮件消息必须是7-bit ASCII

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201104095408513.png" alt="image-20201104095408513" style="zoom:50%;" />

例子：

> 1) Alice使用用户代理编写邮件消息(给bob@someschool.edu的)
>
> 2) Alice的用户代理发送邮件消息 到她的邮件服务器;邮件消息存放在邮件消息队列
>
> 3) Alice邮件服务器的SMTP客户端发起建立一个到Bob的邮件服务器的SMTP服务器端的TCP连接,经过应用层握手.
>
> 4) SMTP客户在这个TCP连接上发送Alice的邮件消息
>
> 5) Bob服务器存放邮件消息存到 Bob的邮箱
>
> 6) Bob调用他的用户代理读邮件消息
>
> 7) 如果Alice的邮件服务器不能将邮件交付给Bob的服务器，她的邮件服务器在一个报文队列中保持该报文并在以后尝试再次发送（每30分钟一次）；如果几天以后仍不能成功，服务器就删除该报文并以电子邮件的形式通知发送方

### SMTP客户和服务器的命令交互

```html
     S: 220 hamburger.edu 
     C: HELO crepes.fr 
     S: 250  Hello crepes.fr, pleased to meet you 
     C: MAIL FROM: <alice@crepes.fr> 
     S: 250 alice@crepes.fr... Sender ok 
     C: RCPT TO: <bob@hamburger.edu> 
     S: 250 bob@hamburger.edu ... Recipient ok 
     C: DATA 
     S: 354 Enter mail, end with "." on a line by itself 
     C: Do you like ketchup? 
     C: How about pickles? 
     C: . 
     S: 250 Message accepted for delivery 
     C: QUIT 
     S: 221 hamburger.edu closing connection
```

### 总结：

- SMTP使用持久连接
- SMTP要求邮件消息（header & body）必须是7-bit ASCII
- SMTP服务器使用CRLF.CRLF来判断邮件消息的结束

**与HTTP的比较**

- HTTP：拉协议（在方便的时候，某些人在web服务器上装载信息，用户使用HTTP从该服务器拉取信息，TCP是由想接收文件的机器发起的）
- SMTP：推协议（发送邮件的服务器把文件推向接收邮件服务器）
- 都有ASCII命令/应答交互，状态码
- HTTP：每个对象封装在它各种的HTTP响应消息中发送
- SMTP：一个邮件内各个对象置于同一个邮件消息的多目部分发送

### 邮件消息的格式

**SMTP：**用来交换邮件消息的协议

**RFC 822：**文本邮件消息格式标准

- 信头-头部行。如：
  - To：
  - From：
  - Subject：
  - 这些头部不同于SMTP命令
- 新题
  - 邮件消息也必须是ASCII字符

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107105929816.png" alt="image-20201107105929816" style="zoom:50%;" />

#### 多媒体扩展

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107105959929.png" alt="image-20201107105959929" style="zoom:50%;" />

简而言之，SMTP同HTTP一样，在head后边包含它的首部行；其中有固定格式（注意，格式不同于指令，指令是对计算机和服务器施加命令，格式只是方便识别使用的）

#### 邮件访问协议

![image-20201107110239822](/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107110239822.png)

**SMTP：**递送/存储邮件服务器到接受者邮件服务器

邮件访问服务器：从服务器获取邮件消息

- POP：Post Office Protocol 邮局协议[RFC 1939]110端口号
  - 身份认证（代理<->服务器）并下载邮件消息
- IMAP：Internet Mail Access Protocol[RFC 1730]
  - 更多功能特性（更复杂）
  - 允许用户像对待本地邮箱那样操作远程邮箱的邮件
- HTTP：Hotmail，Yahoo！Mail，etc

### POP3协议[RFC 1939]

**身份认证阶段**

- 客户命令：

  > user username
  >
  > Pass password

- 服务器响应：

  > +OK
  >
  > -ERR

**传输阶段**

- list：列出邮件编号
- retr：按编号取邮件
- dele：删除
- quit

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107111500114.png" alt="image-20201107111500114" style="zoom:50%;" />

上为认证阶段，下为传输阶段；

#### POP3和IMAP

**POP3的更多：**

- 先前例子使用“Download-and-delete”。
- Bob还客户端后不能再读邮件
- “Download-and-keep”模式：在不同客户机上的邮件
- POP3的会话无状态的

说白了，pop3允许用户将邮件下载到本地，同时删除保存在服务器上的邮件

**IMAP：**

- 保存所有邮件消息在一个位置：服务器
- 允许用户在服务器的各文件夹中管理邮件消息
- IMAP跟踪用户会话的状态信息：
  文件夹和邮件消息IDs与文件夹名字的映射

IMAP和POP3类似，不同在于，用户进行的下载操作，邮件依然会被保存在邮件服务器上，同时在客户端上所进行的操作都会被反馈到服务器上

## DNS：互联网的目录服务

DNS：域名系统Domain Name System

- 人：很多标识符

  ID，name，passport

- Internet主机，路由器

  IP address（32 bit）- 用于分组寻址

  “主机名”，e.g.，gaia.cs.umass.edu-用于人记忆识别

- 可以在IP地址和主机名之间建立映射吗？（可以，因为主机名不能提供主机在互联网中具体位置的标识）

### 域名系统

- 分布式数据库：一个由分层DNS服务器实现的分布式数据库
- 应用层协议：DNS服务器实现域名转换（域名/地址转换）

注：DNS不是一种直接面向用户的应用程序，而是在互联网上的一种核心服务程序，其为应用程序和其他软件提供一种核心功能。DNS通过采用了位于网络边缘的客户和服务器，实现了关键的名字到地址的转换功能。

**DNS服务器提供的功能：**

- 主机名到IP地址的转化：*说白了，用户上网时，将URL输入选框，URL网址被发送到DNS服务器，DNS服务器将其转换为IP地址并返回；用户的浏览器接收到返回的IP地址对HTTP服务器进行请求发送*
- 主机别名
  - 一个主机可以有一个规范主机名和多个主机别名（一个主机名可能复杂rely1.west-cost. Enterprise.com→www.enterprise.com）
- 邮件服务器别名（类似主机别名中的内容）
- 负载分配
  - DNS实现了冗余服务器：一个IP地址可以对应于同一个规范主机名（繁忙的站点可能存在于多个服务器上，因此用一个ip地址集合进行统一标识；同时由于用户通常访问的是最前面的IP地址，DNS会在一些冗余空闲的服务器之间进行循环来分配负载）

**为什么不集中式DNS**

*DNS可能增加网络时延，因此通常使用一个就近的DNS服务器而非一个统一的DNS*

- 单点故障
- 巨大访问量
- 远距离集中式数据库
- 维护

*单一DNS运行集中式数据库完全不可拓展*

### DNS服务器层级

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107160215788.png" alt="image-20201107160215788" style="zoom:50%;" />

没有一台DNS拥有所有主机的映射

三种层级的DNS服务器正如图所示

**根DNS服务器：**管理互联网主目录；一共有13个根目录，专门负责记录顶级域名服务器的信息

**顶级域（DNS）服务器：**全球有400+各个根名字服务器，他们记录了所有顶级域服务器的信息（大型企业、国家、国际组织、政府部门、军事、网络服务和教育等）例如com, org, net, edu, gov；国家顶级域cn, uk, fr, jp, us

- Network solutions 公司维护com顶级域的TLD服务器
- Educause 公司维护edu顶级域的 TLD服务器

**权威DNS服务器：**在因特网上具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。组织机构的权威DNS服务器负责保存这些DNS记录。

- 多数大学和公司维护它们的基本权威DNS服务器

**本地DNS服务器：**严格来说不属于该服务器的层次结构；每个ISP（居民区、公司和大学）都有个本地DNS：也叫默认服务器/当主机发出DNS请求时，该请求被发往本地DNS服务器（起着代理的作用，转发请求到层次结构中）



一次一次循环，先传输到本地服务器，本地服务器从上到下一层一层解析地址，最终权威DNS服务器将IP返回给本地服务器，本地服务器返回给客户机。

### DNS查询方法

#### 递归查询

- 名字解析的负担交给被查询的名字服务器
- 被查询的名字服务器负载重

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107162757150.png" alt="image-20201107162757150" style="zoom:50%;" />

### 迭代查询

- 被查询的服务器回复可以被查询的名字服务器ip地址
- “我不知道它的名字，但是可以问服务器“

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107162824642.png" alt="image-20201107162824642" style="zoom:50%;" />

### DNS缓存和记录更新

- 一旦名字服务器获得DNS映射，它将缓存该映射到局部内存
  - 服务器在一定时间*2天*后将丢弃缓存的信息
  - 本地DNS服务器可以缓存TLD服务器的IP地址（因而根DNS服务器不会被经常访问）
- IETF正在设计动态更新/通报机制
  - RFC 2136

#### DNS记录和报文

DNS：存储资源记录（RR）的分布式数据库

​	RR格式：（name, value, type, ttl）ttl是生存时间，它决定了记录应当从缓存中删除的时间

**Type=A**

- name=主机名
- value=IP地址

**Type=NS**

- name=域名（如foo.com）
- value=该域权威名字服务器的主机名

**Type=CNAME**

- name=主机别名
- value=真实的规范主机名

**Type=MX**

- name=邮件服务器的主机别名
- value=邮件服务器的真实规范主机名

### DNS协议，消息

DNS协议：查询报文和应答报文具有统一的报文格式

- 报文头部

  - 标识符：16位，查询和应答报文使相同的标识符

  - 标志：有若干个标志构成，分别标识不同的功能

    >查询/应答	0/1
    >
    >查询希望是/非递归查询	1/0
    >
    >应答可/缶获得（支持）递归查询	1/0
    >
    >应答是/否来着权威名字服务器	1/0

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107165023939.png" alt="image-20201107165023939" style="zoom:50%;" /><img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107165141530.png" alt="image-20201107165141530" style="zoom:40%;" />

### 在DNS数据库中插入记录

- 在注册登记机构注册我的域名network.com，则

  - 提供资金的基本权威DNS服务器和辅助权威DNS服务器的名字和IP地址
  - 该注册登记机构将下列两条资源记录插入注册机构的DNS系统

  （network.com ,dns1.network.com,NS）

  （dns1.network.com, 212.212.212.1, A）

- 如果要建立一个网站，可以将www.network.com以类型A的方式记录到自己的权威DNS服务器dns1.network.com中

- 如果你想建一个邮件服务器，可以将mail.network.com以类型MX的方式记录到你的权威DNS服务器dns1.nextwork.com中

### DNS攻击

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107170553878.png" alt="image-20201107170553878" style="zoom:50%;" />



## P2P文件共享

**举例**

- Alice在家用PC上运行一个P2P文件共享应用软件

- 每次重新连接因特网时，得到新的IP地址

- 寻找“Hey Jude”

- 应用程序显示有“Hey Jude”拷贝的其他对等方

- Alice 选择一个对等方 Bob.

- 文件从Bob的PC上拷贝在Alice的PC上：HTTP

- 当Alice在下载时，其他用户也在从Alice的PC下载

- Alice的对等方既是一个Web服务器，又是一个瞬时Web服务器

  ​										所有的对等方都是服务器＝高扩展性

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107172538295.png" alt="image-20201107172538295" style="zoom:50%;" />

### P2P：集中式目录的问题

- 单点故障

- 性能瓶颈

- 侵犯版权

  文件传输是分散的，但是定位内容的过程是高度集中的

### 查询洪泛：Gnutella

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107172816983.png" alt="image-20201107172816983" style="zoom:50%;" />

### Gnutella：协议

查询报文在已有的TCP连接上发送

对等方转发报文

QueryHit

​	报文按反向路径传送

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201107175626614.png" alt="image-20201107175626614" style="zoom:50%;" />

#### Gnutella：加入对等方

- 加入对等方X必须发现在Gnutella网络中的其他对等方：使用对等方列表 。
- X视图与该列表上的对等方建立一条TCP连接，直到与Y创建一条连接。
- X向Y发送一个Ping报文；Y转发该Ping报文。
- 所有的对等方接收Ping报文并响应一个Pong报文。
- X接收到许多Pong报文。然后能同某些其他对等方建立TCP连接。

<font color='red'>说白了，这个协议下文件传输是完全点对点无中心的</font>

### KaZaA

- 每个对等方要不被指派为组长，要不被指派给一个组长
  - 对等方和组长之间建立TCP连接
  - 组长之间建立TCP连接
- 组长维护它的子对等方共享的内容

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201108151112148.png" alt="image-20201108151112148" style="zoom:50%;" />

- 每个文件有文件的散列吗标识
- 客户机送向组长发送关键词的查询
- 组长响应匹配
  - 逐项匹配：源数据，散列值，IP地址
- 如果组长转发查询给其它组长则其它组长响应匹配
- 客户端选择要下载的文件
  - HTTP requests using hash as identifier sent to peers holding desired file
- 请求排队：限制对等方并行上载数量，新的请求进行排队
- 激励优先权：根据不同的上载下载比例优先服务贡献大者
- 并行下载：将一个文件分层若干层，从多个对等方并行下载

<font color='red'>说白了，这个协议下文件传输是有中心的</font>

## Socket套接字编程

**Socket API**

- 1981年提出与BSD4.1 UNIX
- 网络应用程序明确的创建，使用及释放套接字
- cs模式
- 通过Socket API提供传输层的2类服务
  - 不可靠的数据报传输
  - 可靠的字节流传输



<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201108154458733.png" alt="image-20201108154458733" style="zoom:50%;" />

### 使用TCP进行套接字编程

**Socket：**应用进程和传输层协议之间的门

**TCP服务：**从1个进程到另1个进程的字节流的可靠传输

**客户必须初始联系服务器**

- 服务器进程必须先运行
- 服务器进程必须创建套接字（门）来迎候客户的初始联系

**客户如何初始联系服务器**

- 创建客户本地TCP socket
- 指定服务器进程的IP地址，端口号
- 一旦客户创建套接字，客户TCP就发起三次握手并建立与服务器的TCP连接
- 一旦客户初始联系（敲门）服务器，服务器TCP为服务器进程创建1个新的socket与客户进程通信
  - 允许服务器与多个客户通信
  - 源端口好被用来区分客户

### 流（Stream）的概念

- 流是流入或流出一个进程的一串字符
- 输入流被加载进程的某个输入源上
  - e.g.标准输入（键盘）或套接字
- 输出流被加在进程的某个输出源上
  - e.g.标准输出（显示器）或套接字

### TCP套接字编程

**客户机/服务器应用程序实例：**

- 客户从它的标准输入读入一行
  - （inFromUser stream），将该行发送到通往服务器的套接字（outToServer stream）
- 服务器从它的连接套接字读入一行
- 服务器将该行转换成大写，然后送回客户机
- 服务器将修改后的行通过其连接套接字再发回给客户机
- 客户从它的套接字中读取、输出修改后的行（inFromServer stream）

### TCP客户/服务器

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201108164157747.png" alt="image-20201108164157747" style="zoom:70%;" />

**案例：使用python编写简单的TCP客户端和服务端程序**

```python
# TCP_Client
from socket import *

ServerName = 'IP or Hostname'
ServerPort = 12000
ClientSocket = socket(AF_INET, SOCK_STREAM)
# 创建了客户的套接字，称为ClientSocket；
# 第一个参数指示底层网络使用的是IPv4
# 第二个参数指示该套接字是SOCK_STREAM类型，表明它是TCP套接字
# PS：此时我们未指定端口号，反而让操作系统进行此操作
ClientSocket.connect((ServerName, ServerPort))
# TCP连接时要通过三次握手建立稳定的TCP连接，这条代码主要是执行三次握手建立连接
# connect方法的参数是这条连接中服务器的地址
sentence = input('Input lowercase sentence')
# 获取报文
ClientSocket.send(sentence.encode())
# 通过客户创建的套接字和报文进行传输
# 不同于UDP，在此传输中无需输入Server地址；因为在先前已经创建好了稳定的TCP连接
# 在此可以直接进行数据的传输
ModifiedSentence = ClientSocket.recv(1024)
# 当报文到达服务器时，它们被放置在字符串ModifiedSentence中。
# 知道回车符结束
print('From server:', ModifiedSentence.decode())
ClientSocket.close()
# 关闭TCP连接

# TCP_Server
from socket import *

ServerPort = 12000
ServerSocket = socket(AF_INET, SOCK_STREAM)
# 创建TCP套接字
ServerSocket.bind(('', ServerPort))
# 将服务器端口号ServerPort与该套接字关联起来
ServerSocket.listen(1)
# 定义请求连接到最大数量
# （如果将TCP连接理解为走亲访友，listen可以算得上是一个等待朋友敲门的过程）
print('The server is ready to receive')
while True:
    ConnectionSocket, Addr = ServerSocket.accept()
    # 在客户敲门时，在程序内创建了一个新套接字，由特定的客户使用。
    # 表示客户和服务器已经完成了握手，在客户端和服务器之间创建了一个TCP连接
    Sentence = ConnectionSocket.recv(1024).decode()
    CapitalizedSentence = Sentence.upper()
    ConnectionSocket.send(CapitalizedSentence.encode())
    ConnectionSocket.close()
    # 关闭套接字

```



### UDP客户服务器

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201112164341733.png" alt="image-20201112164341733" style="zoom:30%;" />

**案例：使用python编写简单的UDP客户端和服务端程序**

```python
# UDP_Server.py
from socket import *
ServerPort = 12000
ServerSocket = socket(AF_INET, SOCK_DGRAM)
# 开头和Client类似，都是导入模块，设置端口号为12000，创建套接字类型为DGRAM
ServerSocket.bind(('', ServerPort))
# 将端口号12000和服务器的套接字进行绑定（即分配）在一起。
# 因而在UDPServer中，开发者编写的代码显式地给套接字分配一个端口号
# 以这种方式，当任何一个人向位于该服务器的IP地址的端口20发送一个分组，分组将导向套接字
# UDPServer然后进入一个循环，允许UDPServer无限期地接收来自用户的分组。
# 在该循环中，UDPServer等待一个分组的到达
print('The server is ready to receive')
while True:
    message, ClientAddress = ServerSocket.recvfrom(2048)
    # 报文被存储在message中，源地址（IP和端口号）被存储与CA中
    # UDPServer将利用该地址信息，因为他提供了返回地址
    ModifiedMessage = message.decode().upper()
    # 将报文转换为字符串并转换为大写
    ServerSocket.sendto(ModifiedMessage.encode(), ClientAddress)
    # 最后一行将该客户的地址（IP地址和端口号）附到大写的报文上（转化为大写后）
    # 并将分组发送到服务器的套接字中（服务器地址也在分组上，这是自动而非由代码完成的）。
    # 因特网将分组交付给客户地址；在服务器发送分组后仍然维持在while循环中，等待另一个UDP分组到达
    
# UDP_Client.py
from socket import *
# 导入socket模块（socket模块是Python所有网络通信的基础）

ServerName = '113.54.199.48'
# 这两行提供了包含服务器的的IP地址或保护服务器的主机名的字符串；
# 若使用主机名，将自动执行DNS lookup从而得到IP地址；将整型变量ServerPort设为12000
ServerPort = 12000
# 创建一条套接字；第一个参数指示地址簇；AF_INET提示服务器使用IPv4；SOCK_DGRAM表明它是一个UDP套接字；
# 在创建套接字时，我们并没有指定端口号，相反我们让操作系统做这件事
ClientSocket = socket(AF_INET, SOCK_DGRAM)
# 输入报文
message = input('Input lowercase sentence:')
ClientSocket.sendto(message.encode(), (ServerName, ServerPort))
# 首先将报文段由字符串转换为字节类型：encode方法；
# 方法sendto为报文附上目的地的地址并向进程的套接字ClientSocket发送结果分组；
# 这是自动完成的而非显性地由代码完成的
ModifiedMessage, ServerAddress = ClientSocket.recvfrom(2048)
# 当一个来自因特网的分组到达客户端套接字时，该分组被存储到ModifiedMessage中
# 其源地址被存储到ServerAddress中（包含了服务器的IP地址和服务器的端口号）
# UDP_Client实际上不需要服务器的详细地址信息（因为它从一开始就知道服务器地址），这行Python代码却依然提供地址信息
# 方法recvfrom取缓存长度为2048作为输入（该缓存长度用于多种目的）
print(ModifiedMessage.decode())
# 将报文从字节转化为字符串，在用户显示器上打印出ModifiedMessage，只是变成了大写态了
ClientSocket.close()
# 关闭套接字，再关闭进程

```

