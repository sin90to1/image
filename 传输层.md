[TOC]

# 运输层

## 运输层服务

### 概述

- 传输层协议为运行在不同主机上的进程之间进行通信提供了*逻辑通信*功能；应用程序使用运输层提供的逻辑通功能彼此发送报文，*无需考虑承载报文的物理基础设施的细节。*
  - 这意味着**运输层协议**是在端系统中实现等待，而不是在路由器中实现的；

- 在发送端，运输层将从发送应用程序接收到的报文转换成运输层分组（传输层报文段）
  - 应用层将报文分成小的块，为每一个报文段加上首部（head）来生成报文段；
  - 在发送端系统中传输层系统将报文段传输给网络层，网络层将之进行封装并发送
- 在接收段，网络层接收报文，运输层处理报文段并转交给进程
- 网络路由器仅仅作用于数据报的网络层字段，不检查封装在数据报的运输层报文段的字段（即：它只管理网络层而不管理运输层的检查）

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201114112458149.png" alt="image-20201114112458149" style="zoom:40%;" />

**运输层与网络层（课本P123有详例）**

在协议栈中，运输层位于网络层上，网络层提供*主机*之间的逻辑通信，而运输层为*进程*之间提供逻辑通讯。

运输层协议能够提供的服务受限于底层网络层协议的服务模型（网络层协议无法提供时延或带宽保证时，运输层同样无法提供这种保证）

即使底层网络协议不能在网络层提供某些服务，运输层协议依然可以提供部分服务（可靠数据传输与加密报文）

### 运输层中的UDP与TCP：

运输层分组👉报文段（segment）[^注1]

**因特网网络层：**

- 网络层协议有一个名字叫做IP（Internet Protocol👉网际协议）；

- IP为主机之间提供了逻辑通信，它的服务模型是==尽力而为交付服务==（说明它无法确保报文段的按序交付和数据的完整性）；
  - 因此它还被称为==不可靠服务==；
- 每一台主机有至少一个网络层地址，即IP地址

**UDP与TCP：将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务**

- 主机间交付扩展到进程间交付被称为==运输层的多路复用==和==多路分解==
- TCP提供了几种附加服务，它提供可靠数据传输；（通过流量控制、符号、确认和定时器来确保数据正确地、按序交付）
  - 拥塞控制：不仅仅提供给进程，还提供给整个互联网，防止任何一条tcp链接使用过多连接来淹没网络

## 多路复用和多路分解

将主机之间的通信延伸到进程之间的通信

在目的主机，运输层从紧邻其下的网络层接收报文段；运输层负责将报文段中的数据交付给在主机上运行的应用程序进程的*套接字*；

一个主机上可能不止一个套接字，因而每个套接字都有一个唯一的标识符（取决于它是UDP还是TCP）

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201114145324351.png" alt="image-20201114145324351" style="zoom:50%;" />

### 无连接的多路复用和多路分解

- 将运输层报文段中的数据交付到正确的套接字的工作被称为==多路分解==。

- 在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有的工作被称为==多路复用==

  > 多路复用有其要求，分别是：
  >
  > - 套接字有唯一标识符
  > - 每个报文段有特殊字段*即为下图所示的源端口号和目的端口号字段*来指示报文段所要交付到的套接字

**传输过程：**

- 主机A创建一个运输层报文段，运输层将得到的报文段传递到网络层。

- 网络层将该报文段封装到IP数据报中，并尽力而为地将报文传输给目的主机。

- 报文段到达主机后，运输层将会检查它的目的端口号（假设是46428），并转交给端口号为46428所标识的套接字

  同样的，如果两个UDP连接源端口号不同但是IP和目的端口号相同，它们将通过相同套接字传输给相同的进程

- 虽然接收方中许多进程，但是每个进程都有自己的UDP套接字和端口号，因而定向传输报文成为了可能；

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201114150418736.png" alt="image-20201114150418736" style="zoom:33%;" /><img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201114153111647.png" alt="image-20201114153111647" style="zoom:50%;" />

### 面向连接的多路分解和多路复用

- 当一个报文段到达一个主机时，主机将使用全部的4个值来将报文段定向对应的套接字。与UDP不同的是，具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字
- 当一个TCP报文段到达主机时，所有的四个字段被用来将报文段定向分解到相应的套接字
- TCP服务器的应用程序有一个欢迎套接字，它用来在端口上等待客户机的连接请求

### 端口号

- 端口号是一个16比特的数，大小在0～65535之间。

- 0～1023的范围被称作周知端口号，是受限制的，这是指它们保留给诸如HTTP和FTP之类的周知应用来使用的，它在RFC1700中提出，同时在RFC3232上有更新文档。

- 当我们开发一个简单应用程序时，必须为它分配一个端口号。

- 在先前的python代码中我们可以使用socket方法来自动分配端口号，或者使用bind方法来为套接字关联一个由我们随意创建的特定端口号；

  - 通常应用程序的客户端让运输层自动地（透明地）分配端口号，而服务器则分配一个特定地端口号

  - **UDP报文段**

    > 一个UDP报文段会包含应用程序数据，源端口号，目的端口号和其他两个值（后面会提到）；
    >
    > 一个UDP套接字是由一个二元组全面标识的👉目的地的IP地址和目的地端口

  - **TCP报文段**

    > 一个TCP套接字是由一个四元组来标示的👉源IP，源端口，目的IP和目的端口号

  - 源端口号的用处：如果服务器想给客户机返回一个报文段，源端口实际上就成为了一个目的端口号（其实就是一种CS交互）

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201114215712890.png" alt="image-20201114215712890" style="zoom:33%;" />

👆上图实际上表现的是一个案例：主机A和B分别向服务器申请了2个HTTP请求和1个HTTP请求；此时服务器为A的两个HTTP分别分配端口号7532和26145，对B的HTTP请求依然分配端口号26145；由于AB拥有不同的IP地址，因此相同的端口号也能进行区分。

当今的很多Web服务器通常只使用一个进程，但是为每个新用户创建一个具有新连接套接字的线程；

如果客户和服务器使用持续HTTP，在整个连接期间，客户和服务器之间经由一个服务器套接字交换HTTP报文；如果是非持续的，可能会有害处（对于繁忙的Web服务器这样可能会很低效）

## 无连接传输：UDP

根据之前所述，传输层在进行数据传输的时候，至少要提供一种复用/分解服务，以便在网络层和正确的应用级之间传递数据

在RFC 768的定义中，UDP仅仅只是做了运输层协议能做的最少工作，除了复用分解功能和少量的差错检测外，它几乎没有为IP增加别的东西；

*之所以被称为是无连接的，是因为UDP在发送报文之前，发送方和接收方不会经历握手！*

**DNS是UDP的重要实例：**

- 一个主机的DNS应用程序想要进行一次查询时，它构造一个DNS查询并将其交给UDP，无需握手
- 主机端的UDP为报文添加首部字符，然后将它直接发送给网络层
- 网络层将报文段封装为一个IP数据报，发送给服务器
- 在客户机上，DNS应用程序等待查询的响应，若无响应它将向其他DNS服务器发送查询；或者告诉客户机它不能获得响应

### TCP是否总是应用开发的首选

答案并非如此。根据需求，很多应用更适合UDP来构建

- 应用层控制更为精细

  > 只要应用将数据交给UDP，UDP会立刻打包并传给网络层进行传输；TCP有拥塞控制机制，在拥塞时会遏制发送；
  >
  > 部分实时应用需要最小的发送时延，且能够容忍部分数据的丢失；

- 无需建立连接

  > TCP需要三次握手；UDP无需此过程

- 无连接状态

  > TCP需要维护连接状态，包括接收和发送缓存、拥塞控制参数和确认号的参数；UDP无需维护连接，也不需要发送这些参数

- 首部分组开支小

  > TCP报文段有20字节的首部开销；UDP只有8字节的首部开销

很多时候，UDP被应用在网络管理程序上（因为在网络繁忙时，难以保证TCP的稳定数据连接）

目前，TCP和UDP都应用于多媒体应用程序；这些程序通常能够容忍少量的数据丢失，因而使用UDP也无妨；但是在TCP时，拥塞控制可能会造成较低的运行效率；

在丢包率比较低的时候，很多机构会出于安全考虑使用TCP

但是这并非不存在问题，UDP没有拥塞控制；如果大量用户同时使用UDP传输高比特的视频会话，可能会造成网络的严重拥塞（目前有一种自适应拥塞控制技术解决这个问题）

**UDP是可以实现可靠数据传输的。这可以通过在应用程序中建立可靠性机制完成（Chrome浏览器使用的QUIC协议可以实现）**

### UDP报文结构

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201119100126655.png" alt="image-20201119100126655" style="zoom:50%;" />

应用层数据占用UDP报文段的数据字段。对于DNS应用，数据字段要么包含一个查询报文，要么包含一个响应报文。对于流式音频应用，音频抽样数据被填充到数据字段。

长度字段用来指示UDP报文段中的字节数（首部+数据）

接收方通过检验和来检查该报文段中是否出现差错

### UDP检验和

UDP提供了差错检测功能。检验和用于确定UDP报文段从源到目的地移动时，其中的比特是否发生变化

发送方的UDP对报文段的16个比特字的和进行==反码运算==，求和时遇到的任何溢出都会被回卷

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201119221536353.png" alt="image-20201119221536353" style="zoom:50%;" />

在最后一行中，由于加法有溢出，要进行==回卷==（就是把溢出的最高位1和低16位做加法运算。例如：原本是（1）0100101011000001，回卷就是0100101011000001+1=0100101011000010）；

之后进行一步反码运算，得到的结果是：1011010100111101；此时为校验和

如果该分组中没有引入差错，接收方的和将是1111111111111111，如果其中之一为0，那么其中可能出现了差错

**为什么UDP首先提供了校验和？**

无法保证所有链路、路由器提供差错检测；因而必须在端到端基础上在运输层提供差错检测

这被称为==端到端原则==

## 可靠数据传输：TCP

数据可以通过一条可靠的信道进行传输；借助于可靠信道，传输数据就不会损坏丢失；

👇图片说明的就是一条可靠信道的框架

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201119224926466.png" alt="image-20201119224926466" style="zoom:35%;" />

虽然TCP协议本身是可靠的，但是它的下层协议（IP协议）不一定是可靠的！，在传输过程中可能造成数据的丢失

因此我们会开发一个可靠数据传输协议的发送方一侧和接收方一侧；通过一套机制来实现数据的可靠传输；

👆图表现了用于数据传输的接口；

- 通过调用rdt_send()函数，上层函数可以调用数据传输协议的发送方。它可以将数据交付给位于接收方的较高层

> rdt表示的是可靠数据传输协议；_send表示的是rdt的发送端正在被使用；

- 在分组从信道的接收端到达时，调用rdt_rcv()函数
- 当rdt协议要向高层交付数据时，通过调用deliver_data实现
- 除了交换含有待传送的数据分组，rdt的发送端和接收端还会往返交换控制分组；发送端和接收端都要通过调用udt_send()*udt表示不可靠数据传输*发送分组给对方
- PS：在此仅考虑单项数据传输的情况（数据仅从发送端到接收端）；双向传输原理与之类似，但是会比较繁琐

### 构造可靠数据传输

#### 经完全信道的可靠数据传输rdt1.0

这是最简单的情况，此时假设底层信道是完全可靠的；接收方接收速率和发送方发送速率一样快；（因而前者没必要请求后者慢一点）

👇图片表示的是rdt1.0发送方和接收方的==有限状态机（Finite State Machine）==

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201120101835797.png" alt="image-20201120101835797" style="zoom:50%;" />

**说明**

其中，发送方和接收方都有各自的FSM；图中的发送方和接收方每个都只有一个状态

箭头表示的是状态的变化，指向自身表示的是只有一个状态

引起状态变化的操作表现在横线上方，事件发生时采取的动作在横线下方；如果没有动作，就在横线上方或者下方使用符号$\Lambda$表示缺少动作

FSM的初始状态用虚线表示（图里只有一个状态，但是后边的rdt会逐渐关注多状态）

**语句解释：**

- 发送端

  > 发送端仅通过rdt_send(data)事件接收来自高层的数据，产生一个包含该数据的分组，并将分组发送到信道中
  >
  > rdt_send(data)是由较高层应用到过程调用产生的

- 接收端

  > rdt通过rdt_rcv(packet)事件从底层信道接收一个分组，
  >
  > 从分组中取出数据（经由extract(packet, data)动作），
  >
  > 并将数据上传给较高层（通过deliever_data(data)动作）
  >
  > 实际上，rdt_rcv(packet)是由较低层协议的过程调用产生的

- 在此，一个单元数据和一个分组没有区别；且所有的分组都是由发送方流向接收方；有了可靠信道，接收端无需提供任何反馈信息给发送方（因为不用担心差错）

#### 经具有比特差错信道的可靠数据传输rdt2.0

底层信道更为实际的模型是分组中的比特可能受损的模型。

在分组的传播、传输和缓存中，网络的的物理部件可能会出现差错导致数据不可靠；

因而在此假设所有发送的分组都将按照其发送的顺序被接收。

如果去比喻rdt2.0：A用电话去口述一条长报文，B作为报文接受者听到理解A说的每一句话并说“OK”，如果B有听不清的，就会说“Please Repeat”

这种口述报文协议就采用了==肯定确认（Positive acknowledgement）==和==否定确认（Negative acknowledgement）==；使得发送方知道哪些被正确接收，哪些接收有误并需要重复

这种机制被称为==自动重传请求（Automatic Repeat reQuest，ARQ）协议==

---

ARQ协议还需要另外三种协议功能来处理存在比特差错的情况

- 差错检测：使接收方可以检测何时出现比特差错；如同UDP中的检验和技术，这里检验和比特汇聚在rdt2.0的数据分组的分组检验和字段中

- 接收方反馈：接收方通过提供明确的反馈信息给发送方使之明白分组是否被正确接收

  > 在口述报文的情况下回答的“肯定确认（ACK）”和“否定确认（NCK）”来实现这种反馈
  >
  > Rdt2.0将从接收方向发送方会送ACK和NAK分组，通常，这些分组只需要一个比特长；如0用NAK，1用ACK

- 重传：接收方知道数据有差错时，发送方进行重传

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201120111526513.png" alt="image-20201120111526513" style="zoom:40%;" />

👆图片内容是rdt2.0的FSM

**发送端：**

- 有两个状态，在左侧状态中，发送端首先等待上层发送数据

- rdt_send(data)中，发送方产生一个包含待发送数据（sndpkt=make_pkt(data,checksum)）

  > make_pkt(data,checksum)在此产生一个分组，主要由发送数据和校验和组成

- 通过udt_send(data)发送数据

- 在右边的状态中，发送方等待来自接收方的ACK或NAK分组；如果是ACK则继续，反之如果是NAK则说明数据有误，发送方重传分组并再次等待ACK/NAK

- 在发送方等待过程中，它无法从上层获取数据（rdt_send()事件不可能出现）

- 因而发送方不会发送新的的数据，除非发送方确信接收方已经接收到正确的分组；基于这种行为，rdt2.0又被称为==停等==协议

**接收方**

- 接收方仍然只有单一状态。分组到达时，接收方要么回答一个ACK，要么回答一个NAK
- rdt_rcv(rcvpkt)&&corrupt(rcvpkt)对应于收到一个分组并发现有错的事件

然而，问题在于，如何保证ACK/NAK分组不受损？因为，如果这两个分组受损，发送方无法知道接收方是否正确接收上一块发送的数据；现在有三种可能的处理方案

- 如果说话人不理解来自接收方回答的内容，他将稳“你说什么？”；接收方将会复述回答。但是如果接收方没有听清这句“你说什么”该怎么办？

- 第二种是增加足够的校验和比特，使得发送方不仅可以检测差错，还可以恢复差错（对于会产生差错但不丢失方分组的信道，这样可以解决问题）

- 第三种方法是，在发送方收到含糊不清的ACK和NAK分组后，他将重传当前数据分组；这种方法引入了冗余分组，但是真正的问题在于：接收方不知道他回复的ACK和NAK是否被接收到，它也不知道这次重传究竟是重传还是新数据！

- 第四种是目前广泛采用（几乎所有的数据传输协议）的一种方法，在数据分组中添加一个新字段，让发送方对数据分组编号，即将发送数据的==序号==放在该字段。

  > 接收方只需要检查序号就可以确定分组是否重传；由于停等协议比较简单，因而采用1比特序号；
  >
  > 这种方法可以让接收方知道发送方是在发送一个新分组（序号变化，用模2运算前向移动）还是在重传一个分组（收到的分组序号和最近的分组序号相同）
  >
  > ACK和NAK分组不需要指明他们要确认的分组序号，因为发送方知道所接受的NAK和ACK是为响应其最近发送的数据而生成的

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201120171440056.png" alt="image-20201120171440056" style="zoom:70%;" />

👆图片表示的是rdt2.1的FSM；它是2.0的修订版；发送方和接收方都是先前的两倍

因为它们需要表现出正发送的分组或接收的分组序号是0还是1；发送方和期望接收方对于0分组和1分组的动作相似，但是序号处理办法不同；

这里面有两种确认方式

- 收到失序分组，接收方发送一个ACK；接收到受损分组，接收方发送一个NAK
- 接收方不发送NAK，对上一个正确接收到分组发一个ACK（发送方收到同一分组的两个ACK——即冗余ACK，同样知道其没有正确接收）

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201120172206695.png" alt="image-20201120172206695" style="zoom:60%;" />

👆图片表示的是rdt2.2，它和2.1的区别在于：其在有比特差错的信道上实现一个无NAK的可靠数据传输协议

此时接收方必须包括由一个ACK报文实现的分组序号（在接收方的FSM中，在make_pkt()包括参数ACK 0或ACK 1来实现）发送方检查ACK报文中获取的分组序号，通过isACK()中包含的参数来实现

---

#### 经具有比特差错的丢包信道的可靠数据传输：rdt3.0

如果除了比特受损外，底层信道还会丢包；该如何检测丢包，如何确定丢包后做什么？

在传统的rdt2.0以及它的各个版本中，如果数据发生了丢包，发送方会等待接收方的ACK码；但是问题在于，这一等待过程可能会很漫长（一个往返时延+接收方处理一个分组的时间）

通常来说，这个时延并不好确定

因而在rdt3.0中，人们设计了一种==倒计时定时器==，通过这种方式确定一个时间值；如果在这个给定时间值的范围内，接收方没有传回一个ACK；发送方会重传数据

也就是说，发送方需要做到：

- 每次发送一个分组时，启动一个计时器
- 响应定时器中断（采取相应工作）
- 终止定时器

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201121151603082.png" alt="image-20201121151603082" style="zoom:50%;" />

👆这是rdt3.0的FSM

👇这是rdt3.0协议运作的情况

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201121151730059.png" alt="image-20201121151730059" style="zoom:50%;" />

分组序号在0/1之间交替，因而rdt3.0有时被称为==比特交替协议==

#### 流水线可靠数据传输协议

Rdt3.0是一个功能正确的协议，但是它的性能并不高！而停等协议是它性能问题的核心；

例如，现有一条1GBps的链路，15ms的端到端传输延迟，1KB的报文：
$$
T_{transmit}=\frac{L(packet\ length\ in\ bits)}{R(transmission\ rate,\ bps)}=\frac{8kb/pkt}{10^{**}9\ b/sec}=8\ microsec
\\U_{sender}=\frac{L/R}{RTT+L/R}=\frac{.008}{30.008}=0.00027
\\U_{sender}:利用率-发送方忙于发送的时间部分
\\1KB\ pkt\ every \ 30 \ msec\to33KB/sec\ throughput\ over\ 1Gbgps\ link
$$
如何解决这种超低利用率的情况？

不以停等方式运行，允许发送方发送多个分组而无需等待确认；如果发送方可以在等待确认之前发送3个报文，那么它的利用率就可以提升三倍

这种处理方法即被称为==流水线技术==

**它使得发送方允许发送多个“在路上的”还没有被确认的报文**

- 序号数目的范围必须增加（因为不同于rdt3.0，此时会同时发送多个分组）
- 发送方和接收方必须有缓冲区（发送方应当缓存哪些没有被确认的分组，而接收方也应该缓存那些已经正确接收的分组）

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201121153531627.png" alt="image-20201121153531627" style="zoom:50%;" />

👆图片的上半部分为rdt3.0，下半部分为流水线技术；

解决流水线的差错恢复有两种基本方法：**回退N步**和**选择重传**

##### 回退N步（Go-Back-N）

- 允许发送方发送多个分组而无需等待确认
- 分组数不能超过最大允许数N

👇图片上是GBN协议的序号范围

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201121155042954.png" alt="image-20201121155042954" style="zoom:50%;" />

我们可以将序号范围分为4节：[0, base-1], [base, nextseqnum-1], [nextseqnum, base+N-1], >= base+N；这些都可以在图上找到对应

不可用的序号需等到未确认的分组得到确认为止；那些已被发送的仍未被确认的分组可以被看作在一个序号范围内长度为N的窗口；随协议的运行，窗口将向前滑动；

- 流水线中发送方最多能发送N（**窗口长度**）个未被确认的分组；

  > 之所以限制长度，是因为TCP要进行拥塞控制
  >
  > 分组序号的范围是[0, 2^k^-1]；其中k是分组序号字段的比特数；在此范围内，所有的序号计算都应该使用模2^k^计算

- GBN协议也被称为滑动窗口协议（因为不断有序号在被确认，亦不断有序号在产生）

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201121161257775.png" alt="image-20201121161257775" style="zoom:50%;" />

👆图中内容展示的是GBN的FSM，发送方和接收方都应该响应一些事件；

**发送方：**

- *上层调用：*上层调用rdt_send(data)时，发送方将首先检查发送窗口是否已满；

  > 如果未满，将产生一个分组并发送；同时更新变量；
  >
  > 如果已满，发送方将数据返回给上层，并指示上层窗口已满，一会儿再发；

- *收到一个ACK：*对序号为N的分组确认采用累计确认的方式，表明接收方已经接收到序号为n的以前且包括n在内的所有分组

- *超时事件：*如同在停等协议中那样，当有一系列分组的确认出现超时时，发送方仍将重新发送

**接收方：**

- 如果正确且按序（上一个是n-1）接收到一个序号为n的分组，将为之发送一个ACK；否则将丢弃该分组。
- 👇正如图片所示，由于必须保证数据的按序交付，在第二组数据丢失的时候，接收方会丢弃后面收到的数据并放弃发送ACK，知道第二组数据交付；
- 这种方法可以使得接收缓存简单，接收方不需要缓存任何失序分组。虽然这种方法有点nt

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201121165518878.png" alt="image-20201121165518878" style="zoom:50%;" />

##### 传输性重传/SR

GBN协议允许发送方用多个分组“填充流水线”，避免停等协议中提到的信道利用率低的问题；但是，它的重传机制可能导致：如果一个分组出了问题，将有一大堆分组需要重传！所以它有点nt；

选择重传，顾名思义，就是让它重传那些被怀疑出错的内容；

这种方法需要：

- 接收方逐个确认已经收到的分组

  > 必要时，缓冲报文，最后按序提交给上层

- 发送方只重发没有收到确认的分组

  > 对每个没有确认的报文发送者都要启动一个定时器（每个未被确认的报文都有一个定时器）

- 发送窗口

  > N个连续序号
  >
  > 限制被发送的未确认的分组数量

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201121171150689.png" alt="image-20201121171150689" style="zoom:50%;" />

在这种机制下，所有已收到的分组将会被缓存直到所有未被收到的分组都被接收，之后所有的分组都将被按序交付

**发送方：**

- *从上层接收数据：*从上方接收数据后，发送方将会检查是否有可用的序号；若有，则将数据打包并发送；若无，则缓存数据或将其返回给上层以便之后传输
- *超时：*每个分组有自己的计时器来防止丢失
- *收到ACK：*收到ACK后，将检查该序号是否在窗口内，将被确认的分组标记为已接收；若分组序号为send_base，则窗口前移；

**接收方：**

- *序号在[rcv_base, rcv_base + N - 1]内的分组被正确接收*：收到的分组落在接收方的窗口内，分组缓存；同时检查分组是否和之前的序号是连续的，若是则直接交付，并将窗口后移

- *序号在[rcv_base-N, rcv_base - 1]内的分组被正确接收：*必须产生一个ACK，即使该分组是接收方之前确认过的分组

  > 接收方重新确认已收到的序号小于当前窗口基序号的分组[^注2]

- *其他情况：*忽略

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201121223531241.png" alt="image-20201121223531241" style="zoom:50%;" />

还有一个问题，就是发送方与接收方的同步问题

由于序号是有限的，如果当发送方和接收方之间缺乏同步，可能会导致一些问题

👇这是第一种情况，此时接收方的ACK码全部丢失，发送方必须重发0，1，2三个分组，接收方还需要缓存三个数据的副本

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201121225710956.png" alt="image-20201121225710956" style="zoom:50%;" />

👆这是第二个情况，三个ACK码都被接收，但是第二组传输中的“3”（第五个分组）丢失

这两种情况是等同的，我们无法确定发送的是第1个分组的重传还是第五个分组的重传

先前所有的内容，都基于一个假设：分组无法在信道中被重新排序；但是当所连接的是一个网络时，这种重新排序是可能出现的；有可能有一个序号x的分组的旧副本会出现

这种可以看做是信道在缓存分组，并任意释放；但是由于序号可以被重复使用，这种冗余分组可能是有害的

因此需要发送方确保一切先前发送的分组不会再出现，这就需要假定一个分组的存活时间（RFC1323定义这一时间在TCP中的存活时间为3分钟）

## 面向连接传输：TCP

TCP的概述在这些文件中有提及：RFCs: 793,1122,1323,2018,2581，其中包含它的差错检测，重传，累计确认，定时器和用于序号和确认号的首部字段

其具有以下特质：

- 点到点

  一个发送着，一个接收者；一个发送方将数据发给多个接收方是不可能的

- 逻辑的

  它并不是物理的，而是一种*逻辑连接*；中间路由器对其连接视而不见，仅仅关注数据报

- 可靠按序的字节流

  没有信息边界

- 流水线

  TCP拥塞和流量控制设置窗口大小

- 收发缓冲区

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201124165653507.png" alt="image-20201124165653507" style="zoom:50%;" />

	> 👆正如图所示，在数据发送前，socket会将报文先存入TCP发送缓存当中；这一缓存是发起三次握手期间设置的；
	>
	> 在那之后，数据会被从发送缓存中取出，TCP会将这些数据以报文段的形式发送。
	>
	> TCP可以从缓存中取出并放入报文段的数据取决于==最大报文段数量（MSS：Maximum Segment Size）==

- 全双工数据：

  同一连接上的双向数据流，TCP在向主机发送数据时也接收从主机发送而来的数据

  MSS：最大报文段长度

  > 通常来说，MSS通常根据最初确定的由本地主机发送的最大链路层帧长度来确定（==最大传输单元（Maximum Transmission Unit）==）。
  >
  > 以太网和PPP链路层都具有1500字节的MTU，减去40字节的TCP/IP首部长度，得到MSS的的典型值为1460字节

- ==面向连接==

  经过三次握手建立连接并初始化状态

  在标识好目标进程后，客户向服务器发送一条特殊报文，服务器用一条报文回应，客户再回复一条报文，这一过程就是三次握手

- 流量控制

  发送方不会淹没接收方

总而言之，TCP连接到组成包括：*一台主机上的缓存、变量和进程套接字，另一台主机上的缓存、变量和进程套接字*

### TCP报文段结构

TCP为每块用户数据配上一个TCP首部，形成多个TCP报文段。这些报文段被下传到网络差中，网络差将它们分别封装在网络层IP数据报中，之后这些IP数据报被发送。

通常来说，一个网页上的数据会被封装成长度为MSS的若干块（除了最后一块）然后发送。

但对于部分应用诸如Telnet，数据子报通常只有1个字节，因而一个报文段总长度为21个字节长。

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201124170959015.png" alt="image-20201124170959015" style="zoom:50%;" />

一个TCP报文段通常包含这些内容

- 首部：源端口号和目的端口号（主要用于多路复用和多路分解），还包括检验和字段（checksum）

- 32比特的序号字段和32比特的确认号字段

  > 序号：数据段中第一个字节在数据流中的位置编号；
  >
  > 例如现在有一个文件大小为500,000字节，其MSS为1000字节；就可以按照下图去分配报文段的序号
  >
  > <img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201124184815540.png" alt="image-20201124184815540" style="zoom:50%;" />

  > 确认号
  >
  > - 期望从另外一端收到的下一个字节的序号
  > - 累计ACK
  >
  > 如果主机接收到来自另一台主机的编号为0～535的所有字节，它将会向那台主机发送一个确认报文段，它将会等待从536开始的所有字节，而那台报文段上将会填入536这个确认号字段。
  >
  > 如果主机接收到0～535点报文段，也接收到635～800的报文段；此时主机仍然会向服务器发送536这个报文段，并且等待536～634的报文段。
  >
  > TCP仅仅会确认到第一个丢失的字节为止的字节
  >
  > - 如何处理失序报文段（即刚刚第二个案例，第二组数据失序怎么办）
  >
  > TCP没有专门的RFC文档提到这个问题，这个问题由编程人员解决；
  >
  > 通常由两种办法
  >
  > 1. 扔掉
  > 2. 保留失序字节，等待缺少的字节补全间隔


- 16比特的接收窗口字段，主要用于流量控制
- 4比特的首部长度字段（指示以32比特为单位的TCP首部长度）
- 可选和变长的选项字段：用于发送方和接收方协商最大报文段长度（MSS），或在告诉网络下用作窗口调节因子使用；首部字段还有一个时间截选项
- 6比特的标志字段：ACK用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。RST、SYN和FIN用于连接建立和拆除；PSH表示接收方应当将数据交给上层；URG用于指示报文段里存在被发送端上层置为“紧急”的数据；紧急数据的最后一个字由==紧急数据指针字段==指出。紧急数据存在并给出指向紧急数据尾指针的时候，TCP必须提醒接收端的上层实体。

#### 典型案例：Telnet（远程登陆控制）

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201124191038477.png" alt="image-20201124191038477" style="zoom:50%;" />



#### 往返时延的估计和超时

如何设置TCP超时值？

- 比RTT长

  但是RTT不断的波动变化（路由器的拥塞和端系统负载的变化）

- 太短：不成熟的超时

  不必要的重传

- 太长：对数据段丢失响应慢

如何估计RTT值？

- 样本RTT（Sample RTT）：测量从报文段发送到收到确认的时间（仅在某个时刻进行测量而不是对每个报文段进行一次测量）

  忽略重传的情况

- 样本RTT会波动，因而需要一个样本RTT均值（Estimated RTT），对收到的新样本RTT进行均值处理

  $EstimatedRTT = (1-\alpha)\times EstimatedRTT+\alpha\times SampleRTT$

  上述均值运算被称为：==指数加权移动平均==

  RFC 6298中给出的$\alpha$推荐值时0.125；因而公式为：

  $EstimatedRTT = 0.875\times EstimatedRTT+0.125\times SampleRTT$

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201124192621063.png" alt="image-20201124192621063" style="zoom:50%;" />

👆图片表示的是RTT的波动变化，而红线则是EstimatedRTT

**设置超时**

除了估算RTT外，测量RTT的变化也是有价值的。RFC 6298定义了==RTT偏差Dev RTT==，用于估算SampleRTT一般会偏离EstimatedRTT的程度；

$DevRT=(1-\beta)\cdot DevRTT+\beta \cdot[SampleRTT-EstimatedRTT]$

通常定义$\beta=0.25$

SampleRTT的波动小时，DevRTT的值会很小；如果波动大则反之

**设置超时时间间隔**

超时时间间隔应当大于ERTT，但是又不能大太多

$TimeoutInterval = EstimatedRTT+4\cdot DevRTT$

在RFC 6298中，超时时间间隔的推荐值为1秒

#### 可靠数据传输

由于IP传输是不可靠的，TCP传输将尽可能创建一种可靠的数据传输机制。这一机制将保证进程从缓存中读出的数据流是无损坏、无间隙、非冗余和按序的。

- TCP在IP不可靠服务基础上创建rdt服务

- 流水线技术处理报文段

- 累计确认

- TCP使用单个重发定时器

  触发重发：超时时间、重复确认

总而来说，TCP的可靠数据传输会使用超时机制来控制数据传输的可靠性。在先前的超时控制中，我们假定的情况是每个报文段都有一个定时器，但实际来说这种机制并不现实（开销）；因此，我们实际上使用单一计时器对时间进行控制。这一定时器是最早没有被确认的数据段发送时被启动的。

同时，我们使用序号来保证数据传输的可靠性（序号是数据段中第一个数据字节在字节流中的位置编号）

**TCP发送方时间：**

​	*从应用程序接收数据：*

- 用序号创建数据段

- 序号是数据段中的第一个字节在字节流中的位置编号

- 如果没有启动定时器，则启动

- 设置TimeoutInterval（利用ERTT和DRTT计算）

  *超时*

- 重发导致超时的数据段

- 重新开始定时器

  *收到确认*

- 如果确认了还没有确认的数据段

  更新还没有确认的状态

  还有未完成的数据段，重新开始定时器

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201125160109541.png" alt="image-20201125160109541" style="zoom:50%;" />

**TCP的重发场景**

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201125162219568.png" alt="image-20201125162219568" style="zoom:50%;" />

👆图中分为两种情况

左边的是丢失ACK的情况；当A向B发送一个8字节的报文段，首字节的序号是92。B收到了报文，回发了序号为100的确认码。但是确认码丢包，此时A受超时机制影响重发报文。B收到重发报文，对比序号发现已经接收过，因此将此时接收的报文抛弃，并重发确认码。

右边的是由于过早的超时设置导致的。由于在超时之前两个确认码没有一个到达A，因此A必须重发两个报文

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201125163042383.png" alt="image-20201125163042383" style="zoom:50%;" />

👆这种情况主要是过长的Timeout设置造成的。ACK100丢包，但是A接收到了ACK120，因此其认为对方已经接收到了序号92到序号120的所有数据

**超时间隔加倍**

在TCP重传时，它会优先重传有最小序号且还未被确认的报文段。但是在每次重传时，TCP会将下一次的超时间隔设为原先的两倍，超时间隔会在每次重传后呈指数增长。

然而，每当定时器因为收到上层引用数据和收到ACK的任意一个启动时，TimeoutInterval将由最近的EstimatedRTT和DEVRTT得到。

这实际上是一种拥塞控制，当许多数据报经过路由器时，有可能导致网络拥塞和丢包。此时TCP的重传时间将增加，从而达到拥塞控制的效果。

**快速重传**

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201125164838558.png" alt="image-20201125164838558" style="zoom:50%;" />

👆图片表示了冗余ACK的相关处理方法

由于发送方经常一个接一个的发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。如果TCP收到相同数据的3个冗余ACK，他就知道这3个冗余ACK后面的报文段已经丢失。此时ACK执行==快速重传==：即在报文段的定时器过期前重传已丢失的报文段

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201125170208024.png" alt="image-20201125170208024" style="zoom:50%;" />

👆这是快速重传的算法演示



<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201125170333361.png" alt="image-20201125170333361" style="zoom:50%;" />

👆这是快速重传的过程表现

图中，ACK=100的确认报文丢失，即便它以及后边的所有报文段都被B接收到，此时A只会重传报文段100，而如果100后边的报文段在超时之前到达，TCP甚至不会重传100。

如此能看出来，TCP确实不属于GBN，而看起来是一种SR协议。但实际上，人们将TCP定义为一种==选择确认==。TCP接收方有选择地确认报文段，而非累计的确认最后一个。不过实际上，TCP的差错恢复机制被分类为GBN协议和SR协议的混合体。

#### 流量控制

TCP的接收方会设置一个缓存区；但是应用程序有可能因为忙于其它事务，使它从缓存区读数据很慢。而发送方会不间歇的发送数据，如果发送的太快，可能会导致缓存溢出。

因此，TCP提供了速度匹配服务（==流量控制服务==），使得发送速率和接收应用程序的提取速率匹配。

流量控制不等于拥塞控制，即使两者都是对发送方进行遏制，动作也相似；

此时先假设TCP接收方会丢弃失序的报文段。

- 流量控制使用==接收窗口==：用于指示缓冲区的剩余空间
- 接收方在报文段中宣告接收窗口的剩余空间
- 发送方限制没有确认的数据不超过接收窗口，来保证接收方的缓冲区不溢出。

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201125173944778.png" alt="image-20201125173944778" style="zoom:50%;" />

RevWindow用rvwd来表示，使用RcvBuffer来表示接收缓存，LastByteRead表示接收方从缓存读出的数据流的最后一个字节的编号，LastByteRcvd表示从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号

根据上面我们根据的

LastByteRcvd-LastByteRead<=RcvBuffer

rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]

在刚开始时，rwnd=RcvBuffer

发送方轮流跟踪两个变量：LastByteSent和LastByteAcked，这两个变量的意义和明显。

两个变量之间的差LastByteSent-LastByteAcked就是发送方发送到连接中但又未被确认的数据量；因而主机A需要保证：LastByteSent-LastByteAcked<=rwnd

但是此时存在一个问题，如果B的缓存满了，B又没有任何数据要发给A；此时B仅仅会将缓存清空却不会给A发送带有rwnd值的ACK

这种情况会导致A以为B已经满了，从而不会向B发送任何数据；但是B的缓存已经清空了！

TCP的规范中有一个处理方法：A向B发送一个1字节的报文段，B接收并确认，最终缓存开始清空，确认报文中将包含一个非零的rwnd值

#### TCP连接管理

TCP在交换数据报歉在发送方和接收方之间建立连接

- 初始化TCP变量

  序号

  缓存区流量控制信息

- 客户：连接发起者（使用之前的代码发起连接）

- 服务器：被客户联系

**连接建立：**

*三次握手：*

1. 客户发送TCP SYN报文段给服务器

   指定初始的序号（随机）这一序号叫做client_isn，这一序号会被封装在一个IP报文中并发给服务器。

   SYN报文没有任何数据；

2. 服务器接收SYN，回复SYNACK报文段

   服务器提出SYB报文段，服务器为该TCP连接分配缓冲区，并向客户机发送允许连接到报文段

   指定服务器的初识序号，这一序号叫做server_isn；表示：我收到了SYN分组，该分组带有初始序号client_isn；我同意建立一个序号为server_isn的连接

3. 客户接收SYNACK，回复ACK报文段，可能包含数据；

   收到SYNACK后，客户分配缓存和变量。由于连接已经确认，SYN比特被置为0。而这第三个阶段可以在报文段负载中携带客户到服务器的数据

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201126114720001.png" alt="image-20201126114720001" style="zoom:50%;" />

*如何终止？*👉我们称之为“四次握手”

参与TCP连接的两方都能够终止连接；

- 如果客户打算终止连接，客户端将会服务器发送一个专门的报文段，其首部有一个专门的标志位**FIN比特**，它将被设置为1。

- 服务器接收到报文段后，发送一个“确认终止报文段”，半关闭连接，发送FIN到客户

- 客户收到FIN，回复ACK；

  进入“timed wait"（定时等待）

  等待结束时释放连接资源

- 服务器接收ACK，连接关闭

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201128145538451.png" alt="image-20201128145538451" style="zoom:50%;" />

👇图片展示的是一般TCP连接的整体状态

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201128150241740.png" alt="image-20201128150241740" style="zoom:50%;" />

简单来说，结束的过程是双方互动的一个过程

**补充内容：DoS攻击/SYN洪泛攻击**

在三次握手过程中，客户机向TCP发送SYN报文，服务器回复SYNACK报文并设置一个半开的连接，同时等待客户机的最终ACK报文

但是这一过程可能会被人攻击，攻击者可能会发送大量SYN报文，服务器设置大量的半开的连接导致资源被耗尽。

但是有一种对应方案，即：SYN Cookie方案

服务器每接收到一个SYN报文时，不会给它开放一个半开连接，并为之生成一个初始TCP序列号（cookie），该序列号是一个复杂函数，仅服务器知道，服务器不会记录关于cookie和任何对应于SYN的其他信息

如果客户是合法的，服务器将检验客户返回的ACK码的IP、端口号和秘密运行的散列函数，如果函数值+1和SYNACK中的确认（cookie）值相同的话，服务器认为该ACK对应较早的报文段并生成一个带有socket的全开连接

若非法，则完全无害（因为根本分配开放连接）

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201128152608380.png" alt="image-20201128152608380" style="zoom:50%;" />

**补充内容：不匹配的情况**

当一个主机接收到一个端口号和源IP地址和套接字中内容都不匹配的TCP连接，它将返回一个特殊重置报文段，并将RST标志位置为1，意为：“我没有那个报文段的套接字，请不要再发送报文段了”

如果是一个不匹配的UDP端口，服务器将返回一个ICMP报文段

**补充内容：nmap端口扫描工具**

nmap可以探索目标主机上一个特定的TCP端口，如果源主机从目标主机接收到一个TCP SYNACK报文段，这表示目标主机上有匹配的TCP端口，nmap返回打开

如果目标主机返回一个TCP RST报文段，说明SYN报文段可以到达目标主机，但是上面没有对应的端口；但是源主机知道报文段没有被任何防火墙阻挡

如果源什么都没有收到，表面SYN报文段可能被防火墙阻挡

nmap可以用来侦查打开的TCP端口/UDP端口，也可以侦查防火墙及其配置，也可以侦查程序版本、操作系统

## 拥塞控制原理

**拥塞：**

- 从信息的角度来看：“太多源主机发送太多数据，速度太快以至于网络来不及处理”

- 和流量控制不同

- 表现：

  丢失分组（路由器缓冲区溢出）

  长延迟（在路由器缓冲区排队）

主要有几种情况，在此一一列举进行解释：

### 场景一

**假设：**

- 两个发送者，两个接受者
- 一个路由器，无限缓冲区（用于分组到达速率超过该输出链路容量时存储“入分组”）
- 不执行重发

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201128160101520.png" alt="image-20201128160101520" style="zoom: 67%;" />![image-20201128160120843](/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201128160120843.png)

![image-20201128160120843](/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201128160120843.png)

**结果：**

- 每个主机最大可以达到吞吐量的C/2，总的吞吐量为C，链路不能以超过C/2的稳定状态向接收方交付分组（这是有两条连接之间共享链路容量造成的
- 但是，拥塞时延在发送速率到达C/2达到无限大

### 场景2

**假设：**

- 一个路由器，有限缓冲区
- 发送方重发被路由器丢失的报文

此时用λ~in~表示应用将初始数据发送到套接字中的速率，用λ~in~^'^表示运输层向网络中发送报文的速率，它有时亦被称为网络的==供给载荷==

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201128162719998.png" alt="image-20201128162719998" style="zoom:50%;" />

此时性能强烈地依赖重传的方式。

PS：每幅图表示的是不同情况下的性能

*第一种情况：主机可以知道路由器中的缓存是否空闲，仅当缓存空闲时发送一个分组。*

此时λ~in~=λ~in~'，且λ~in~=连接的吞吐量

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201128164747892.png" alt="image-20201128164747892" style="zoom:50%;" />

此时性能是理想的，但是此时平均主机发送速率不能超过R/2，因为假定不会发生分组丢失

*第二种情况：发送方仅当在确定一个分组丢失时才重传*

此时λ~out~<λ~in~'；在λ~in~'=R/2时，数据被交付给接收方应用程序的速率时R/3。因而如果发送的0.5R单位数据，将有0.333R字节/秒是初始数据，而将有0.166R字节/秒是重传数据

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201129123007422.png" alt="image-20201129123007422" style="zoom:50%;" />

*第三种情况：发送方可能会提前发生超时并重传在队列中已经被推迟但还未丢失的分组。*

此时可能路由器会做大量的无用功，因为会有大量的报文重传

此时λ~out~>λ~in~'；👇图片表示的是当每个分组平均被转发两次时，吞吐量的变化

<img src="/Users/sin90wei1/Library/Application Support/typora-user-images/image-20201129131516228.png" alt="image-20201129131516228" style="zoom:50%;" />

### 场景3





## TCP拥塞控制



[^注1]:这里是为了简化定义，因为很多地方对数据包、报文段有大量的细化定义
[^注2 ]: 这种机制是比较重要的，因为如此才能保证发送方的序号窗口正常前移

